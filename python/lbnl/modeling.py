#!/usr/bin/python


"""
Utilities for modeling wavefields with sw4 and maybe some other codes later
"""

import numpy as np


try:
    import pySW4 as sw4
except ImportError:
    print("pySW4 not found, SW4 functionality disabled")



def frac_to_ifile(frac_path, origin=(1200, -910, 300), vertical_thickness=0.2):
    """
    Write a file with frac xyz to an sw4 material interface file

    :param frac_path: path to the frac file
    :param origin: (x, y, z) origin of the model (meters HMC; elevation masl)
    :param vertical_thickness: vertical distance between the two interfaces (meters)
    :return: None
    """
    array = np.loadtxt(frac_path)
    array[:, 0] = array[:, 0] - origin[0]
    array[:, 1] = array[:, 1] - origin[1]
    array[:, 2] = array[:, 2] - origin[2]
    # Sort the array so that column 1 changes fastest, then column 2
    array = array[np.lexsort((array[:, 1], array[:, 0]))]
    # Write the first interface
    ifile1 = frac_path.replace(".txt", "_ifile1.txt")
    with open(ifile1, "w") as f:
        for i in range(len(array)):
            f.write(f"{array[i][0]} {array[i][1]} {array[i][2]} {array[i][2] - vertical_thickness}\n")
    return


def write_sw4_input(path, ifiles, material, inventory, outdir, origin=(1200, -910, 300), tmax=1.0):
    """
    Write a collab rfile for SW4
    
    :param path: path to write the input file to
    :param ifiles: list of interface files
    :param material: Dict with keys Vp, Vs, rho
    :param inventory: obspy Inventory object
    :param origin: (x, y, z) origin of the model (meters HMC; elevation masl)
    :param dt: time step (seconds)
    :param tmax: max time (seconds)
    :return: None
    """
    with open(path, "w") as f:
        # Write the header
        f.write("# SW4 input file\n")
        f.write("# Generated by write_sw4_input\n")
        f.write("#\n")
        f.write(f'fileio path={outdir} verbose=2 printcycle=100 pfs=1\n')
        f.write(f'time {tmax}\n')
        f.write('grid x=60 y=60 z=60 h=0.1\n')
        # Now the sources/stations
        for sta in inventory[0]:  # Assumes only one network in this inventory
            if sta.code[-2] == 'S':  # Source
                coords = sta.extra
                x = (coords['hmc_east'].value * .3048) - origin[0]
                y = (coords['hmc_north'].value * .3048) - origin[1]
                z = (coords['hmc_elev'].value * .3048) - origin[2]
                f.write('source x={x} y={y} z={z} freq=1000. type=ricker\n')
            else:  # Hydrophone or accelerometer
                coords = sta.extra
                x = (coords['hmc_east'].value * .3048) - origin[0]
                y = (coords['hmc_north'].value * .3048) - origin[1]
                z = (coords['hmc_elev'].value * .3048) - origin[2]
                # Note here that, for grouted hydrophones you should use strain then convert to stress tensor
                # ...pressure in a solid is the mean compressive stress.
                f.write(f'rec x={x} y={y} z={z} sta={sta.code} variables=velocity\n')
        # Now the material properties
        f.write(f'block vp={material["Vp"]} vs={material["Vs"]} rho={material["rho"]}\n')
        for i, ifile in enumerate(ifiles):
            f.write(f'ifile filename={ifile} input=cartesian\n')
            f.write(f'material id={i} vp=0.1 vs=0.1 rho=0.1\n')
        # Need to change lz boundary condition to 2 (sepergrid; same as all others)
        f.write('boundary_conditions lz=2\n')
    return